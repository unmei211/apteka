CREATE EXTENSION IF NOT EXISTS pgcrypto;


CREATE TABLE IF NOT EXISTS enc_medicines(
    id int primary key generated by default as identity ,
    original_name text,
    encrypted_name bytea
);

CREATE TABLE IF NOT EXISTS keys
(
    key bytea primary key ,
    id  SERIAL NOT NULL
);


CREATE OR REPLACE FUNCTION encrypt_name(original_name name, encryption_key bytea)
    RETURNS BYTEA AS
$$
BEGIN
    RETURN pgp_sym_encrypt(original_name, encryption_key::text, 'cipher-algo=aes256'::text);
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION decrypt_name(encrypted_name bytea, encryption_key bytea)
    RETURNS TEXT AS
$$
BEGIN
    RETURN pgp_sym_decrypt(encrypted_name::bytea, encryption_key::text, 'cipher-algo=aes256'::text);
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION encrypt_name_trigger()
    RETURNS TRIGGER AS
$$
declare
    key bytea = gen_random_bytes(16);
BEGIN
    NEW.encrypted_name := encrypt_name(NEW.original_name, key);
    insert into keys values (key, NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER before_insert_encrypt
    BEFORE INSERT
    ON enc_medicines
    FOR EACH ROW
EXECUTE FUNCTION encrypt_name_trigger();

INSERT INTO enc_medicines(original_name)
values ('my medicine');

select *
from keys;

select *
from enc_medicines;

select enc_medicines.id, decrypt_name(encrypted_name, KEYS.KEY)
from enc_medicines
         join keys on enc_medicines.id = keys.ID;

CREATE OR REPLACE FUNCTION decrypt_name_and_out(encr_name bytea) RETURNS TABLE(decrypted_name TEXT) AS $$
DECLARE
    decryption_key bytea;
BEGIN

    SELECT key INTO decryption_key
    FROM keys
    WHERE id = (SELECT id FROM enc_medicines WHERE encrypted_name = encr_name LIMIT 1);

    RETURN QUERY SELECT decrypt_name(encr_name::bytea, decryption_key) AS decrypted_name;
END;
$$ LANGUAGE plpgsql;

SELECT decrypt_name_and_out('\xC30D04090302093A78745F7176D961D23C01746D2208E522813ADBB749F4178D555260D94173AB231FFB17E9DD7D84805C2FDB0011C781D17882FBA4C7579081D7FB5C644A9535707D91131B36')
